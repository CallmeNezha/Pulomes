// Generated by CoffeeScript 1.10.0
(function() {
  var Hexahedron, PBDParticle, axes, boxBasicMaterial, boxGeometry, boxObj, camera, clock, geometry, geometryTopo, global, gui, h, initScene, initStats, light, orbitControls, planeGeo, planeMat, planeObj, ref, render, renderer, restVolume, scene, sphereBasicMaterial, sphereGeometry, sphereObj, stats, trans, updatePlaneConstrains, wnv;

  global = {
    computeVolume: function(vertices, faceIndices) {
      var i, j, norm, p1, p2, p3, pSum, ref, v21, v31, volume;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      pSum = new THREE.Vector3(0, 0, 0);
      volume = 0;
      for (i = j = 0, ref = faceIndices.length - 1; j <= ref; i = j += 3) {
        p1 = vertices[faceIndices[i]].position;
        p2 = vertices[faceIndices[i + 1]].position;
        p3 = vertices[faceIndices[i + 2]].position;
        pSum.addVectors(p1, p2).add(p3);
        v21.subVectors(p2, p1);
        v31.subVectors(p3, p1);
        norm.crossVectors(v21, v31);
        volume += pSum.dot(norm);
      }
      return volume /= 18;
    },
    computeVolumeTHREE: function(vertices, faces) {
      var i, j, norm, p1, p2, p3, pSum, ref, v21, v31, volume;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      pSum = new THREE.Vector3(0, 0, 0);
      volume = 0;
      for (i = j = 0, ref = faces.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        p1 = vertices[faces[i].a];
        p2 = vertices[faces[i].b];
        p3 = vertices[faces[i].c];
        pSum.addVectors(p1, p2).add(p3);
        v21.subVectors(p2, p1);
        v31.subVectors(p3, p1);
        norm.crossVectors(v21, v31);
        volume += pSum.dot(norm);
      }
      volume /= 18;
      return console.log(volume);
    },
    generateTopologyModelTHREE: function(vertices, faces) {
      var face, i, j, len, vertexTopo;
      vertexTopo = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = vertices.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          results.push([]);
        }
        return results;
      })();
      for (i = j = 0, len = faces.length; j < len; i = ++j) {
        face = faces[i];
        vertexTopo[face.a].push(i);
        vertexTopo[face.b].push(i);
        vertexTopo[face.c].push(i);
      }
      return vertexTopo;
    },
    computeWeighedNorms: function(topology, vertices, faces) {
      var face, fi, j, k, len, len1, norm, normSum, p1, p2, p3, v21, v31, vtopo, wnvector;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      wnvector = [];
      for (j = 0, len = topology.length; j < len; j++) {
        vtopo = topology[j];
        normSum = new THREE.Vector3(0, 0, 0);
        for (k = 0, len1 = vtopo.length; k < len1; k++) {
          fi = vtopo[k];
          face = faces[fi];
          p1 = vertices[face.a];
          p2 = vertices[face.b];
          p3 = vertices[face.c];
          v21.subVectors(p2, p1);
          v31.subVectors(p3, p1);
          norm.crossVectors(v21, v31);
          normSum.add(norm);
        }
        normSum.multiplyScalar(0.5);
        wnvector.push(normSum);
      }
      return wnvector;
    },
    computeVolumeByWeighedNorms: function(weightedNorms, vertices) {
      var i, j, len, v, volume;
      volume = 0;
      for (i = j = 0, len = vertices.length; j < len; i = ++j) {
        v = vertices[i];
        volume += v.dot(weightedNorms[i]);
      }
      return volume /= 9;
    },
    computeVolumeConstrain: function(restVolume, topology, vertices, faces, options) {
      var coff, correct, corrects, curVolume, diff, j, k, len, len1, localWeights, normSq, w, wNorms;
      localWeights = options != null ? options.localWeights.localWeights : void 0;
      wNorms = global.computeWeighedNorms(topology, vertices, faces);
      curVolume = global.computeVolumeByWeighedNorms(wNorms, vertices);
      diff = curVolume - restVolume;
      normSq = 0;
      for (j = 0, len = wNorms.length; j < len; j++) {
        w = wNorms[j];
        normSq += w.lengthSq();
      }
      coff = normSq !== 0 ? diff * 3 / normSq : 0;
      if (normSq === 0) {
        console.warn("scope " + this + ": normSq appear 0, please check function \"computeVolumeConstrain\"");
      }
      corrects = [];
      for (k = 0, len1 = wNorms.length; k < len1; k++) {
        w = wNorms[k];
        correct = new THREE.Vector3().copy(w);
        correct.multiplyScalar(-coff);
        corrects.push(correct);
      }
      return corrects;
    },
    initShapeMatchingConstraint: initShapeMatchingConstraint
  };

  PBDParticle = (function() {
    function PBDParticle(x, y, z, mass) {
      this.previous = new THREE.Vector3(x, y, z);
      this.position = new THREE.Vector3(x, y, z);
      this.original = new THREE.Vector3(x, y, z);
      this.velocity = new THREE.Vector3(0, 0, 0);
      this.tmp = new THREE.Vector3();
      this.tmp2 = new THREE.Vector3();
      this.mass = mass;
      this.invmass = this.mass === 0 ? 0 : 1 / this.mass;
      this.a = new THREE.Vector3(0, 0, 0);
    }

    PBDParticle.prototype.addForce = function(force) {
      this.tmp.copy(force).multiplyScalar(this.invmass);
      return this.a.add(this.tmp);
    };

    PBDParticle.prototype.integrate = function(deltaTime, drag) {
      var diff;
      diff = this.tmp2;
      this.velocity.add(this.a.multiplyScalar(deltaTime));
      diff.copy(this.velocity).multiplyScalar(drag * deltaTime).add(this.position);
      this.tmp2 = this.previous;
      this.previous = this.position;
      this.position = diff;
      return this.a.set(0, 0, 0);
    };

    return PBDParticle;

  })();

  Hexahedron = (function() {
    function Hexahedron(vertices, mass) {
      var j, len, pos, v;
      this.particleMass = mass / 8;
      this.particleInvmass = this.particleMass === 0 ? 0 : 1 / this.particleMass;
      this.particles = [];
      for (j = 0, len = vertices.length; j < len; j++) {
        v = vertices[j];
        pos = v.position;
        this.particles.push(new PBDParticle(pos.x, pos.y, pos.z, this.particleMass));
      }
    }

    Hexahedron.prototype.addVolumeConstrain = function() {};

    return Hexahedron;

  })();

  initStats = function() {
    var stats;
    stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    return stats;
  };

  initScene = function() {
    var camera, orbitControls, renderer, scene;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = -30;
    camera.position.y = 40;
    camera.position.z = 30;
    camera.lookAt(scene.position);
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xEEEEEE);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    orbitControls = new THREE.OrbitControls(camera);
    orbitControls.autoRotate = false;
    return {
      scene: scene,
      camera: camera,
      renderer: renderer,
      orbitControls: orbitControls
    };
  };

  stats = initStats();

  document.getElementById("stats-output").appendChild(stats.domElement);

  ref = initScene(), scene = ref.scene, camera = ref.camera, renderer = ref.renderer, orbitControls = ref.orbitControls;

  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0x666666, 1.6));

  light = new THREE.DirectionalLight(0xdfebff, 1.0);

  light.position.set(50, 200, 100);

  light.castShadow = true;

  light.shadow.camera.near = 2;

  light.shadow.camera.far = 1000;

  light.shadow.camera.left = -500;

  light.shadow.camera.right = 500;

  light.shadow.camera.top = 500;

  light.shadow.camera.bottom = -500;

  light.shadow.mapSize.width = 1024;

  light.shadow.mapSize.height = 1024;

  scene.add(light);

  axes = new THREE.AxisHelper(20);

  scene.add(axes);

  boxGeometry = new THREE.BoxGeometry(10, 10, 10, 3, 3, 3);

  boxBasicMaterial = new THREE.MeshStandardMaterial({
    color: 0x22b5ff
  });

  boxObj = new THREE.SceneUtils.createMultiMaterialObject(boxGeometry, [boxBasicMaterial]);

  boxObj.position.set(0, 0, 0);

  scene.add(boxObj);

  boxObj.visible = true;

  sphereGeometry = new THREE.SphereGeometry(5, 32, 32, 0, 4 * Math.PI);

  sphereBasicMaterial = new THREE.MeshStandardMaterial({
    color: 0x22b5ff
  });

  sphereObj = new THREE.SceneUtils.createMultiMaterialObject(sphereGeometry, [sphereBasicMaterial]);

  sphereObj.position.set(0, 0, 0);

  scene.add(sphereObj);

  sphereObj.visible = false;

  geometry = boxGeometry;

  console.log(global.computeVolumeTHREE(geometry.vertices, geometry.faces));

  geometryTopo = global.generateTopologyModelTHREE(geometry.vertices, geometry.faces);

  wnv = global.computeWeighedNorms(geometryTopo, geometry.vertices, geometry.faces);

  restVolume = global.computeVolumeByWeighedNorms(wnv, geometry.vertices);

  console.log(restVolume);

  planeGeo = new THREE.PlaneGeometry(50, 50);

  planeMat = new THREE.MeshBasicMaterial({
    color: 0x22b5ff,
    side: THREE.DoubleSide
  });

  planeMat.transparent = true;

  planeMat.opacity = 0.1;

  planeObj = new THREE.Mesh(planeGeo, planeMat);

  planeObj.rotation.x = Math.PI / 2;

  planeObj.position.set(0, 20, 0);

  scene.add(planeObj);

  trans = new THREE.Vector3(0, 0, 0);

  gui = new dat.GUI();

  h = gui.addFolder("Vertex Position");

  h.add(planeObj.position, "y", -3, 50);

  updatePlaneConstrains = function() {
    var correctY, j, len, ref1, results, v;
    ref1 = geometry.vertices;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      v = ref1[j];
      correctY = THREE.Math.clamp(v.y, -5, planeObj.position.y);
      results.push(v.y = correctY);
    }
    return results;
  };

  clock = new THREE.Clock();

  render = function() {
    var corrects, delta, i, j, len, ref1, v, volume;
    delta = clock.getDelta();
    orbitControls.update(delta);
    updatePlaneConstrains();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    geometry.normalsNeedUpdate = true;
    geometry.verticesNeedUpdate = true;
    corrects = global.computeVolumeConstrain(restVolume, geometryTopo, geometry.vertices, geometry.faces);
    ref1 = geometry.vertices;
    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
      v = ref1[i];
      v.add(corrects[i]);
    }
    wnv = global.computeWeighedNorms(geometryTopo, geometry.vertices, geometry.faces);
    volume = global.computeVolumeByWeighedNorms(wnv, geometry.vertices);
    console.log(volume);
    stats.update();
    requestAnimationFrame(render);
    return renderer.render(scene, camera);
  };

  render();

}).call(this);

//# sourceMappingURL=PBDVolume.js.map
