// Generated by CoffeeScript 1.10.0
(function() {
  var EdgeStrainConstrain, Solver, eSC1, h_2, i, j, kmath, massSpring, positions, solver;

  kmath = {
    subVectors: function(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    },
    lengthSq: function(v) {
      return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    },
    length: function(v) {
      return Math.sqrt(this.lengthSq(v));
    },
    divVector: function(v, scalar) {
      v[0] /= scalar;
      v[1] /= scalar;
      return v[2] /= scalar;
    },
    mulVector: function(v, scalar) {
      v[0] *= scalar;
      v[1] *= scalar;
      return v[2] *= scalar;
    },
    createZeroMatrix: function(row, column) {
      var c, j, mt, r, ref, tmp;
      mt = [];
      for (r = j = 0, ref = row; 0 <= ref ? j < ref : j > ref; r = 0 <= ref ? ++j : --j) {
        mt.push(tmp = (function() {
          var k, ref1, results;
          results = [];
          for (c = k = 0, ref1 = column; 0 <= ref1 ? k < ref1 : k > ref1; c = 0 <= ref1 ? ++k : --k) {
            results.push(0);
          }
          return results;
        })());
      }
      return mt;
    },
    createIndentityMatrix: function(row) {
      var j, mt, r, ref;
      mt = this.createZeroMatrix(row, row);
      for (r = j = 0, ref = row; 0 <= ref ? j < ref : j > ref; r = 0 <= ref ? ++j : --j) {
        mt[r][r] = 1;
      }
      return mt;
    },
    diagonalMultiply: function(mt, scalar) {
      var j, r, ref, results;
      results = [];
      for (r = j = 0, ref = mt.length; 0 <= ref ? j < ref : j > ref; r = 0 <= ref ? ++j : --j) {
        results.push(mt[r][r] *= scalar);
      }
      return results;
    },
    getColumn: function(mt, c) {
      var j, r, ref, results;
      results = [];
      for (r = j = 0, ref = mt.length; 0 <= ref ? j < ref : j > ref; r = 0 <= ref ? ++j : --j) {
        results.push(mt[r][c]);
      }
      return results;
    }
  };

  h_2 = 1 / 900;

  Solver = (function() {
    function Solver(points) {
      this.points = points;
      this.projections = void 0;
      this.constrains = [];
      this.ASMtRowId = 0;
      this.ASMt_t = [];
      this.N = void 0;
      this.ASSparse = void 0;
      this.ASSparse_t = void 0;
      this.elements = [];
      this.M = void 0;
      this.LUP = void 0;
    }

    Solver.prototype.addConstrain = function(constrain) {
      return this.constrains.push(constrain);
    };

    Solver.prototype.initialize = function() {
      var c, e, j, k, len1, len2, ref, ref1;
      ref = this.constrains;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        c = ref[j];
        this.ASMtRowId = c.addConstrainMt(this.elements, this.ASMtRowId);
      }
      this.ASMt_t = kmath.createZeroMatrix(this.ASMtRowId, this.points.length);
      this.projections = kmath.createZeroMatrix(this.ASMtRowId, 3);
      ref1 = this.elements;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        e = ref1[k];
        this.ASMt_t[e[0]][e[1]] += e[2];
      }
      this.ASSparse = numeric.ccsSparse(this.ASMt_t);
      this.ASMt_t = numeric.transpose(this.ASMt_t);
      this.ASSparse_t = numeric.ccsSparse(this.ASMt_t);
      this.N = numeric.ccsDot(this.ASSparse_t, this.ASSparse);
      this.M = kmath.createIndentityMatrix(this.points.length);
      kmath.diagonalMultiply(this.M, 1 / h_2);
      this.N = numeric.ccsadd(numeric.ccsSparse(this.M), this.N);
      return this.LUP = numeric.ccsLUP(this.N);
    };

    Solver.prototype.solve = function() {
      var ax, c, i, j, k, len1, len2, m, momentum, q, qs, ref, results, rhs, sum, vs;
      ref = this.constrains;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        c = ref[j];
        c.project(this.points, this.projections);
      }
      sum = numeric.dotMMbig(this.ASMt_t, this.projections);
      momentum = numeric.dotMMbig(this.M, this.points);
      rhs = numeric.add(momentum, sum);
      results = [];
      for (c = k = 0; k < 3; c = ++k) {
        vs = kmath.getColumn(rhs, c);
        qs = numeric.ccsLUPSolve(this.LUP, vs);
        ax = (function() {
          switch (c) {
            case 0:
              return "x";
            case 1:
              return "y";
            case 2:
              return "z";
          }
        })();
        for (i = m = 0, len2 = qs.length; m < len2; i = ++m) {
          q = qs[i];
          this.points[i][c] = q;
          ax += " " + q;
        }
        results.push(console.log("" + ax));
      }
      return results;
    };

    return Solver;

  })();

  EdgeStrainConstrain = (function() {
    function EdgeStrainConstrain(positions, pid1, pid2, weight, rangeMin, rangeMax) {
      var len;
      if (rangeMin == null) {
        rangeMin = 1;
      }
      if (rangeMax == null) {
        rangeMax = 1;
      }
      this.pid1 = pid1;
      this.pid2 = pid2;
      this.rMin = rangeMin;
      this.rMax = rangeMax;
      len = kmath.length(kmath.subVectors(positions[pid2], positions[pid1]));
      this.invRest = len === 0 ? 0 : 1 / len;
      this.weight = weight * Math.sqrt(len);
      this.cid = -1;
    }

    EdgeStrainConstrain.prototype.addConstrainMt = function(elements, row) {
      this.cid = row;
      elements.push([row, this.pid1, -this.weight * this.invRest]);
      elements.push([row, this.pid2, this.weight * this.invRest]);
      return ++row;
    };

    EdgeStrainConstrain.prototype.project = function(positions, projections) {
      var edge, l;
      edge = kmath.subVectors(positions[this.pid2], positions[this.pid1]);
      l = kmath.length(edge);
      kmath.divVector(edge, l);
      l = THREE.Math.clamp(l * this.invRest, this.rMin, this.rMax);
      kmath.mulVector(edge, l * this.weight);
      return projections[this.cid] = edge;
    };

    return EdgeStrainConstrain;

  })();

  massSpring = [[0, 0, 0], [1, 0, 0]];

  positions = massSpring;

  eSC1 = new EdgeStrainConstrain(positions, 0, 1, 10000);

  solver = new Solver(positions);

  solver.addConstrain(eSC1);

  solver.initialize();

  solver.solve();

  massSpring[1][0] = 5;

  for (i = j = 0; j < 1; i = ++j) {
    solver.solve();
  }

  console.log(kmath.length(kmath.subVectors(massSpring[0], massSpring[1])));

}).call(this);

//# sourceMappingURL=ProjectiveTest.js.map
